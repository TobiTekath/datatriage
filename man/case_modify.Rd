% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/case_modify.R
\name{case_modify}
\alias{case_modify}
\title{A general vectorised switch() that keeps unaffected values}
\usage{
case_modify(.x, ...)
}
\arguments{
\item{.x}{A vector to match against.}

\item{...}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}> A sequence of two-sided
formulas: \code{old_values ~ new_value}. The right hand side (RHS) determines
the output value for all values of \code{.x} that match the left hand side
(LHS).

The LHS must evaluate to the same type of vector as \code{.x}. It can be any
length, allowing you to map multiple \code{.x} values to the same RHS value.
If a value is repeated in the LHS, i.e. a value in \code{.x} matches to
multiple cases, the first match is used.

The RHS inputs will be coerced to their common type. Each RHS input will be
\link[vctrs:theory-faq-recycling]{recycled} to the size of \code{.x}.}
}
\value{
A vector with the same size as .x.
}
\description{
A convenience wrapper around \code{\link[dplyr:case_match]{dplyr::case_match()}}, with \code{.default} set to the input parameter \code{.x} (i.e. keeping values unaffected by any switch statements as they are)
}
\examples{
dummy_df <- data.frame("a" = c(1:3))
# only replace 3 by 4, keep the rest
dplyr::mutate(dummy_df, a = case_modify(a, 3 ~ 4))
}
